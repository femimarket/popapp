// @ts-nocheck
          /**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { AppExecuteMsg, AppExecuteMsgFactory } from "@abstract-money/core";
import { InstantiateMsg, ExecuteMsg, OrderType, Decimal, HexBinary, Trade, QueryMsg, MigrateMsg, ConfigResponse, TradeResponse, GetPriceResponse, QuotePrice, Timestamp } from "./Pop.types";
export interface PopMsg {
contractAddress: string;
sender: string;
updateConfig: (funds_?: Coin[]) => MsgExecuteContractEncodeObject;
increment: (funds_?: Coin[]) => MsgExecuteContractEncodeObject;
reset: ({
  count
}: {
  count: number;
}, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
trade: ({
  data
}: {
  data: Trade;
}, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
tradeCiphertext: ({
  ciphertext,
  digest
}: {
  ciphertext: number[];
  digest: HexBinary;
}, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class PopMsgComposer implements PopMsg {
sender: string;
contractAddress: string;

constructor(sender: string, contractAddress: string) {
  this.sender = sender;
  this.contractAddress = contractAddress;
  this.updateConfig = this.updateConfig.bind(this);
  this.increment = this.increment.bind(this);
  this.reset = this.reset.bind(this);
  this.trade = this.trade.bind(this);
  this.tradeCiphertext = this.tradeCiphertext.bind(this);
}

updateConfig = (funds_?: Coin[]): MsgExecuteContractEncodeObject => {
  const _msg = {
    update_config: {}
  };
  const moduleMsg: AppExecuteMsg<ExecuteMsg> = AppExecuteMsgFactory.executeApp(msg);
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender: this.sender,
      contract: this.contractAddress,
      msg: toUtf8(JSON.stringify(moduleMsg)),
      funds: funds_
    })
  };
};
increment = (funds_?: Coin[]): MsgExecuteContractEncodeObject => {
  const _msg = {
    increment: {}
  };
  const moduleMsg: AppExecuteMsg<ExecuteMsg> = AppExecuteMsgFactory.executeApp(msg);
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender: this.sender,
      contract: this.contractAddress,
      msg: toUtf8(JSON.stringify(moduleMsg)),
      funds: funds_
    })
  };
};
reset = ({
  count
}: {
  count: number;
}, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
  const _msg = {
    reset: {
      count
    }
  };
  const moduleMsg: AppExecuteMsg<ExecuteMsg> = AppExecuteMsgFactory.executeApp(msg);
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender: this.sender,
      contract: this.contractAddress,
      msg: toUtf8(JSON.stringify(moduleMsg)),
      funds: funds_
    })
  };
};
trade = ({
  data
}: {
  data: Trade;
}, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
  const _msg = {
    trade: {
      data
    }
  };
  const moduleMsg: AppExecuteMsg<ExecuteMsg> = AppExecuteMsgFactory.executeApp(msg);
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender: this.sender,
      contract: this.contractAddress,
      msg: toUtf8(JSON.stringify(moduleMsg)),
      funds: funds_
    })
  };
};
tradeCiphertext = ({
  ciphertext,
  digest
}: {
  ciphertext: number[];
  digest: HexBinary;
}, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
  const _msg = {
    trade_ciphertext: {
      ciphertext,
      digest
    }
  };
  const moduleMsg: AppExecuteMsg<ExecuteMsg> = AppExecuteMsgFactory.executeApp(msg);
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender: this.sender,
      contract: this.contractAddress,
      msg: toUtf8(JSON.stringify(moduleMsg)),
      funds: funds_
    })
  };
};
}